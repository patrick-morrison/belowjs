<!--
  Adrasan ‚Äì VR Measurement Tool
  -------------------------------------------------------
  ‚Ä¢ Desktop/phone: Orbit drag & scroll, double-click to focus, click panel to measure.
  ‚Ä¢ Quest 2 VR   : Thumbsticks to move/fly/turn, Y button to toggle measuring.
  ‚Ä¢ Precision measurement system; KTX2, Draco & Meshopt decoding.
-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Adrasan ‚Äì VR Measurement Tool</title>
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#041729">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Wreck Surveyor">
<link rel="apple-touch-icon" href="icons/icon-192x192.png">
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#111;color:#eee;font-family:sans-serif}
  #info{position:absolute;top:10px;left:10px;z-index:10;background:rgba(0,0,0,.55);padding:6px 10px;border-radius:6px;font-size:13px;line-height:1.3em;max-width:300px}
  #modelSelector{position:absolute;top:10px;left:50%;transform:translateX(-50%);z-index:10;background:rgba(0,0,0,.8);padding:8px 12px;border-radius:6px;border:2px solid #87cefa}
  #modelSelector select{background:#222;color:#eee;border:1px solid #555;padding:4px 8px;border-radius:4px;font-size:14px;cursor:pointer}
  #modelSelector select:hover{border-color:#87cefa}
  #hakanCredit{position:absolute;top:10px;right:10px;z-index:10;background:rgba(0,0,0,.8);padding:12px 16px;border-radius:8px;font-size:16px;font-weight:bold;color:#FFD700;border:2px solid #FFD700;text-align:center;min-width:200px}
  #hakanCredit .title{font-size:18px;margin-bottom:4px}
  #hakanCredit .name{font-size:20px;color:#FFF}
  a{color:#87cefa;text-decoration:none}
</style>
<script type="importmap">{"imports":{"three":"https://cdn.jsdelivr.net/npm/three@0.177.0/build/three.module.js"}}</script>
</head>
<body>
<div id="info">
  <strong>Adrasan VR Tool</strong><br>
  <strong>VR:</strong> Thumbsticks to move/fly/turn | Y button to toggle measuring<br>
  <strong>Desktop:</strong> Drag to orbit | Scroll to zoom | Double-click to focus<br>
  <strong>Measure:</strong> Click panel to toggle, then click points to measure
</div>

<div id="modelSelector">
  <label for="modelSelect" style="margin-right: 8px; font-weight: bold;">Model:</label>
  <select id="modelSelect">
    <option value="adrasan">Adrasan</option>
    <option value="adrasan-before">Adrasan Before</option>
  </select>
</div>

<div id="hakanCredit">
  <div class="title">Model by</div>
  <div class="name">HAKAN ONIZ</div>
</div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.177.0/examples/jsm/controls/OrbitControls.js';
import { GLTFLoader }  from 'https://cdn.jsdelivr.net/npm/three@0.177.0/examples/jsm/loaders/GLTFLoader.js';
import { DRACOLoader } from 'https://cdn.jsdelivr.net/npm/three@0.177.0/examples/jsm/loaders/DRACOLoader.js';
import { KTX2Loader }  from 'https://cdn.jsdelivr.net/npm/three@0.177.0/examples/jsm/loaders/KTX2Loader.js';
import { MeshoptDecoder } from 'https://cdn.jsdelivr.net/npm/three@0.177.0/examples/jsm/libs/meshopt_decoder.module.js';
import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@0.177.0/examples/jsm/webxr/VRButton.js';
import { XRControllerModelFactory } from 'https://cdn.jsdelivr.net/npm/three@0.177.0/examples/jsm/webxr/XRControllerModelFactory.js';

// Import the Line2 materials for thick lines
import { Line2 } from 'https://cdn.jsdelivr.net/npm/three@0.177.0/examples/jsm/lines/Line2.js';
import { LineMaterial } from 'https://cdn.jsdelivr.net/npm/three@0.177.0/examples/jsm/lines/LineMaterial.js';
import { LineGeometry } from 'https://cdn.jsdelivr.net/npm/three@0.177.0/examples/jsm/lines/LineGeometry.js';

// ------------------------ Config ----------------------------
// Multiple model configuration
const MODELS = {
  'adrasan': {
    url: 'models/adrasan.glb',
    name: 'Adrasan',
    credit: 'Hakan Oniz'
  },
  'adrasan-before': {
    url: 'models/adrasan-before.glb',
    name: 'Adrasan Open',
    credit: 'Hakan Oniz'
  }
};

let currentModelKey = 'adrasan'; // Default model
let MODEL_CONFIG = MODELS[currentModelKey];
const MOVE_SPEED = 2.0;    // m/s base movement speed
const TURN_SPEED = 1.5;    // rad/s turn speed
const FLY_SPEED = 1.0;     // m/s vertical movement
const TELEPORT_DISTANCE = 5.0; // max teleport distance

// Debug flag to disable normal maps for testing shimmer
const DISABLE_NORMAL_MAPS = false; // Set to true to disable normal maps temporarily

// Anti-seam shimmer settings
const ANTI_SEAM_MODE = true; // Enable aggressive anti-seam filtering

//-------------------------------------------------------------

// Scene basics
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0a1a2a); // Deeper ocean blue

const camera = new THREE.PerspectiveCamera(65, window.innerWidth/window.innerHeight, 0.05, 2000);
const dolly  = new THREE.Group(); dolly.add(camera); scene.add(dolly);

const renderer = new THREE.WebGLRenderer({antialias:true,powerPreference:'high-performance'});
renderer.setPixelRatio(Math.min(window.devicePixelRatio,2.0)); // Limit pixel ratio to reduce shimmer
renderer.setSize(window.innerWidth,window.innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0; // Reduced exposure to minimize overexposure shimmer
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.xr.enabled = true;

document.body.appendChild(renderer.domElement);
document.body.appendChild(VRButton.createButton(renderer));

// Desktop orbit controls
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true; 
controls.dampingFactor = 0.08;
controls.maxDistance = 100;
controls.minDistance = 0.5;

// Cancel focus animation when user manually controls camera
controls.addEventListener('start', () => {
  if (focusAnimation) {
    cancelAnimationFrame(focusAnimation);
    focusAnimation = null;
  }
});

// Movement state
const moveState = {
  isMoving: false,
  buttonPressed: false,
  moveVector: new THREE.Vector3(),
  rotationTarget: 0,
  currentRotation: 0
};

// Raycaster for interactions
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

// Controller tracking spheres - make twice as big
const sphereGeometry = new THREE.SphereGeometry(0.02, 8, 6); // 4cm radius, low-poly
const ghostMaterial = new THREE.MeshBasicMaterial({color: 0xffffff, transparent: true, opacity: 0.2});
const placedMaterial = new THREE.MeshBasicMaterial({color: 0xffffff});

// Maximum of 2 placed spheres
const MAX_SPHERES = 2;
const placedSpheres = [];
const ghostSpheres = {
  left: new THREE.Mesh(sphereGeometry, ghostMaterial),
  right: new THREE.Mesh(sphereGeometry, ghostMaterial)
};

// Add line between spheres - make it show through objects
let connectionLine = null;
const lineMaterial = new THREE.LineBasicMaterial({ 
  color: 0xffffff, 
  transparent: true, 
  opacity: 0.5,
  linewidth: .1,
  depthTest: false // This makes the line render on top of everything
});

// Replace the VR line material with proper initialization
const vrLineMaterial = new LineMaterial({
  color: 0xffffff,
  linewidth: 3, // Much thicker for testing - 5 pixels
  transparent: true,
  opacity: 0.8,
  depthTest: false,
  vertexColors: false,
  dashed: false
});

// Replace the desktop line material with proper initialization  
const desktopLineMaterial = new LineMaterial({
  color: 0xffffff,
  linewidth: 3, // Much thicker for testing - 5 pixels
  transparent: true,
  opacity: 0.8,
  depthTest: false,
  vertexColors: false,
  dashed: false
});

// Add ghost spheres to scene
ghostSpheres.left.visible = false;
ghostSpheres.right.visible = false;
scene.add(ghostSpheres.left);
scene.add(ghostSpheres.right);

// Measurement variables - declared early to avoid initialization errors
let measurementSprite = null;
let measurementCanvas = null;
let measurementTexture = null;
let measurementSystemEnabled = true; // Start enabled
let yButtonPressed = false; // Track Y button state
let desktopMeasurementMode = false; // Desktop measurement mode toggle

// Desktop measurement variables
let desktopMeasurementPoints = [];
let desktopMeasurementLine = null;
let desktopMeasurementDisplay = null;
const MAX_DESKTOP_POINTS = 2;

// Create unified measurement panel for both VR and desktop
function createMeasurementPanel() {
  const panel = document.createElement('div');
  panel.id = 'measurementPanel';
  panel.style.cssText = `
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 16px 20px;
    border-radius: 12px;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    font-size: 16px;
    font-weight: 600;
    z-index: 100;
    cursor: pointer;
    border: 2px solid rgba(255, 255, 255, 0.3);
    backdrop-filter: blur(5px);
    transition: all 0.3s ease;
    user-select: none;
    min-width: 120px;
    text-align: center;
  `;
  
  // Add hover effects
  panel.addEventListener('mouseenter', () => {
    panel.style.background = 'rgba(0, 0, 0, 0.8)';
    panel.style.borderColor = 'rgba(255, 255, 255, 0.5)';
  });
  
  panel.addEventListener('mouseleave', () => {
    panel.style.background = 'rgba(0, 0, 0, 0.7)';
    panel.style.borderColor = 'rgba(255, 255, 255, 0.3)';
  });
  
  // Toggle measurement mode on click
  panel.addEventListener('click', () => {
    if (!renderer.xr.isPresenting) {
      desktopMeasurementMode = !desktopMeasurementMode;
      updateMeasurementPanel();
      
      if (!desktopMeasurementMode) {
        clearDesktopMeasurement();
      }
    } else {
      // In VR, toggle the VR measurement system
      measurementSystemEnabled = !measurementSystemEnabled;
      updateMeasurementPanel();
      
      if (!measurementSystemEnabled) {
        // Clear VR measurements
        ghostSpheres.left.visible = false;
        ghostSpheres.right.visible = false;
        placedSpheres.forEach(sphere => scene.remove(sphere));
        placedSpheres.length = 0;
        if (connectionLine) {
          scene.remove(connectionLine);
          connectionLine = null;
        }
        if (measurementSprite) {
          measurementSprite.visible = false;
        }
      }
    }
  });
  
  document.body.appendChild(panel);
  return panel;
}

// Initialize measurement panel early
const measurementPanel = createMeasurementPanel();

// Update measurement panel function with safety check
function updateMeasurementPanel() {
  if (!measurementPanel) return; // Safety check
  
  const isVR = renderer.xr.isPresenting;
  const isEnabled = isVR ? measurementSystemEnabled : desktopMeasurementMode;
  const hasPoints = isVR ? placedSpheres.length : desktopMeasurementPoints.length;
  const hasMeasurement = isVR ? (placedSpheres.length === 2) : (desktopMeasurementPoints.length === 2);
  
  if (!isEnabled) {
    measurementPanel.innerHTML = `
      <div style="color: #888;">MEASURE</div>
      <div style="font-size: 12px; margin-top: 4px;">Click to enable</div>
    `;
    measurementPanel.style.borderColor = 'rgba(136, 136, 136, 0.3)';
  } else if (hasMeasurement) {
    const distance = isVR ? 
      placedSpheres[0].position.distanceTo(placedSpheres[1].position) :
      desktopMeasurementPoints[0].position.distanceTo(desktopMeasurementPoints[1].position);
    
    measurementPanel.innerHTML = `
      <div style="color: white;">${distance.toFixed(2)}m</div>
      <div style="font-size: 12px; margin-top: 4px;">Click to disable</div>
    `;
    measurementPanel.style.borderColor = 'rgba(255, 255, 255, 0.5)';
  } else {
    const mode = isVR ? 'VR' : 'Desktop';
    const instruction = isVR ? 'Use triggers' : 'Click points';
    measurementPanel.innerHTML = `
      <div style="color: #FFA726;">MEASURE: ON</div>
      <div style="font-size: 12px; margin-top: 4px;">${instruction} (${hasPoints}/2)</div>
    `;
    measurementPanel.style.borderColor = 'rgba(255, 167, 38, 0.5)';
  }
}

// Double-click focus system
let lastClickTime = 0;
const DOUBLE_CLICK_TIME = 300;
let focusAnimation = null; // Track ongoing animation

window.addEventListener('resize',()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});

// Mouse/touch interaction
renderer.domElement.addEventListener('click', onMouseClick);

// Add these variables near the top with other declarations
let isDragging = false;
let dragStartPosition = { x: 0, y: 0 };
const DRAG_THRESHOLD = 5; // pixels

// Add mouse event listeners for drag detection
renderer.domElement.addEventListener('mousedown', onMouseDown);
renderer.domElement.addEventListener('mousemove', onMouseMove);
renderer.domElement.addEventListener('mouseup', onMouseUp);

function onMouseDown(event) {
  isDragging = false;
  dragStartPosition.x = event.clientX;
  dragStartPosition.y = event.clientY;
}

function onMouseMove(event) {
  if (!isDragging) {
    const deltaX = Math.abs(event.clientX - dragStartPosition.x);
    const deltaY = Math.abs(event.clientY - dragStartPosition.y);
    
    if (deltaX > DRAG_THRESHOLD || deltaY > DRAG_THRESHOLD) {
      isDragging = true;
    }
  }
}

function onMouseUp(event) {
  // Reset drag state after a short delay to allow click event to process
  setTimeout(() => {
    isDragging = false;
  }, 10);
}

// Update the onMouseClick function to check for dragging
function onMouseClick(event) {
  const currentTime = Date.now();
  const isDoubleClick = currentTime - lastClickTime < DOUBLE_CLICK_TIME;
  lastClickTime = currentTime;
  
  if (renderer.xr.isPresenting || isDragging) return; // Don't place spheres when dragging
  
  // Calculate mouse position
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  
  // Raycast from camera
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(scene.children, true);
  
  if (intersects.length > 0) {
    // Filter out measurement spheres and lines from intersections
    const validIntersects = intersects.filter(intersect => 
      !desktopMeasurementPoints.includes(intersect.object) &&
      intersect.object !== desktopMeasurementLine &&
      intersect.object !== connectionLine &&
      !placedSpheres.includes(intersect.object)
    );
    
    if (validIntersects.length > 0) {
      if (isDoubleClick) {
        // Double-click: focus on point
        focusOnPoint(validIntersects[0].point);
      } else if (desktopMeasurementMode) {
        // Single click: place measurement point (only if measurement mode is active and not dragging)
        const intersectionPoint = validIntersects[0].point;
        
        // If we already have max points, remove the oldest one
        if (desktopMeasurementPoints.length >= MAX_DESKTOP_POINTS) {
          const oldestSphere = desktopMeasurementPoints.shift();
          scene.remove(oldestSphere);
        }
        
        // Create new measurement sphere using VR style (white spheres)
        const measurementSphere = new THREE.Mesh(sphereGeometry, placedMaterial);
        measurementSphere.position.copy(intersectionPoint);
        scene.add(measurementSphere);
        desktopMeasurementPoints.push(measurementSphere);
        
        updateDesktopMeasurement();
      }
    }
  }
}

function focusOnPoint(point) {
  // Cancel any existing focus animation
  if (focusAnimation) {
    cancelAnimationFrame(focusAnimation);
    focusAnimation = null;
  }
  
  const startTarget = controls.target.clone();
  const startPosition = camera.position.clone();
  
  // Calculate new camera position (maintain relative offset)
  const offset = startPosition.clone().sub(startTarget);
  const newPosition = point.clone().add(offset);
  
  // Smooth animation
  const duration = 1000; // 1 second
  const startTime = performance.now();
  
  function animate() {
    const elapsed = performance.now() - startTime;
    const progress = Math.min(elapsed / duration, 1);
    const eased = 1 - Math.pow(1 - progress, 3); // ease-out cubic
    
    controls.target.lerpVectors(startTarget, point, eased);
    camera.position.lerpVectors(startPosition, newPosition, eased);
    
    if (progress < 1) {
      focusAnimation = requestAnimationFrame(animate);
    } else {
      focusAnimation = null; // Animation complete
    }
  }
  
  focusAnimation = requestAnimationFrame(animate);
}

// Neutral lighting setup - boosted for better visibility
const ambientLight = new THREE.AmbientLight(0xffffff, 0.8); // Increased ambient light
scene.add(ambientLight);

const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2); // Increased hemisphere light
scene.add(hemisphereLight);

// Main directional light - boosted for better illumination
const mainLight = new THREE.DirectionalLight(0xffffff, 2.5); // Much stronger directional light
mainLight.position.set(10, 20, 10);
mainLight.castShadow = true;
mainLight.shadow.mapSize.width = 2048;
mainLight.shadow.mapSize.height = 2048;
mainLight.shadow.camera.near = 0.5;
mainLight.shadow.camera.far = 100;
mainLight.shadow.camera.left = -20;
mainLight.shadow.camera.right = 20;
mainLight.shadow.camera.top = 20;
mainLight.shadow.camera.bottom = -20;
scene.add(mainLight);

// Fill light from opposite side - boosted
const fillLight = new THREE.DirectionalLight(0xffffff, 1.5); // Much stronger fill light
fillLight.position.set(-10, 10, -10);
scene.add(fillLight);

// Add a third light from below for better surface detail visibility
const bottomLight = new THREE.DirectionalLight(0xffffff, 0.8); // Boosted bottom light
bottomLight.position.set(0, -10, 0);
scene.add(bottomLight);

// Loaders setup with better error handling and progress
const draco = new DRACOLoader().setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.177.0/examples/jsm/libs/draco/');
const ktx2  = new KTX2Loader().setTranscoderPath('https://cdn.jsdelivr.net/npm/three@0.177.0/examples/jsm/libs/basis/').detectSupport(renderer);

const loader = new GLTFLoader();
loader.setDRACOLoader(draco);
loader.setKTX2Loader(ktx2);
loader.setMeshoptDecoder(MeshoptDecoder);
loader.setDRACOLoader(draco);
loader.setKTX2Loader(ktx2);
loader.setMeshoptDecoder(MeshoptDecoder);

// Add loading indicator
const loadingDiv = document.createElement('div');
loadingDiv.style.cssText = `
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(0, 0, 0, 0.8);
  color: white;
  padding: 20px;
  border-radius: 8px;
  font-family: sans-serif;
  z-index: 1000;
  display: none;
`;
loadingDiv.innerHTML = 'Loading model...';
document.body.appendChild(loadingDiv);

// Load the wreck with progress tracking
let wreck = null;

// Function to load a model by key
function loadModel(modelKey = currentModelKey) {
  // Update current model and config
  currentModelKey = modelKey;
  MODEL_CONFIG = MODELS[modelKey];
  
  // Remove existing model if present
  if (wreck) {
    scene.remove(wreck);
    wreck = null;
  }
  
  // Clear measurements when loading model
  clearAllMeasurements();
  
  // Show loading indicator
  loadingDiv.innerHTML = `Loading ${MODEL_CONFIG.name}...`;
  loadingDiv.style.display = 'block';
  
  // Update page title
  document.title = `Wreck Surveyor ‚Äì ${MODEL_CONFIG.name}`;
  
  loader.load(
    MODEL_CONFIG.url,
    gltf => {
      wreck = gltf.scene;
      
      // Enhance materials for better texture quality and reduce shimmer
      wreck.traverse((child) => {
        if (child.isMesh) {
          const material = child.material;
          if (material) {
            console.log('üîç Material found:', material.name || 'unnamed');
            console.log('  - Diffuse map:', !!material.map);
            console.log('  - Normal map:', !!material.normalMap);
            console.log('  - Roughness map:', !!material.roughnessMap);
            console.log('  - Metalness map:', !!material.metalnessMap);
            console.log('  - AO map:', !!material.aoMap);
            
            // Ensure proper color space for textures
            if (material.map) {
              material.map.colorSpace = THREE.SRGBColorSpace;
              material.map.flipY = false; // Important for GLTF
              
              // Check if texture format supports mipmap generation
              const supportsAutoMipmaps = !material.map.isCompressedTexture;
              if (supportsAutoMipmaps) {
                material.map.generateMipmaps = true; // Enable mipmaps to reduce shimmer
                material.map.minFilter = THREE.LinearMipmapLinearFilter; // Better filtering
                console.log('  üìä Auto-mipmaps enabled for uncompressed texture');
              } else {
                // For compressed textures (KTX2), use aggressive anti-seam filtering
                material.map.generateMipmaps = false;
                
                if (ANTI_SEAM_MODE) {
                  // Try to force mipmap generation even for compressed textures
                  try {
                    material.map.generateMipmaps = true;
                    material.map.minFilter = THREE.LinearMipmapLinearFilter;
                    console.log('  üîß Forced mipmap generation for compressed texture');
                  } catch (e) {
                    material.map.minFilter = THREE.LinearFilter;
                    console.log('  üì¶ Compressed texture - forced linear filtering');
                  }
                } else {
                  material.map.minFilter = THREE.LinearFilter; // Linear filtering without mipmaps
                  console.log('  üì¶ Compressed texture detected - using linear filtering without mipmaps');
                }
              }
              
              material.map.magFilter = THREE.LinearFilter;
              material.map.anisotropy = renderer.capabilities.getMaxAnisotropy(); // Reduce shimmer at angles
              
              // Anti-seam shimmer settings
              material.map.wrapS = THREE.ClampToEdgeWrapping; // Prevent seam artifacts
              material.map.wrapT = THREE.ClampToEdgeWrapping; // Prevent seam artifacts
              material.map.offset.set(0, 0); // Ensure no texture offset issues
              material.map.repeat.set(1, 1); // Ensure proper texture scaling
              
              console.log('  ‚úÖ Diffuse texture configured with anti-shimmer and anti-seam settings');
            }
            if (material.normalMap) {
              if (DISABLE_NORMAL_MAPS) {
                console.log('  üö´ Normal maps disabled for testing - setting to null');
                material.normalMap = null;
                material.normalScale = null;
              } else {
                material.normalMap.colorSpace = THREE.LinearSRGBColorSpace;
                material.normalMap.flipY = false;
                material.normalMap.generateMipmaps = true;
                material.normalMap.minFilter = THREE.LinearMipmapLinearFilter;
                material.normalMap.magFilter = THREE.LinearFilter;
                material.normalMap.anisotropy = renderer.capabilities.getMaxAnisotropy();
                
                // Anti-seam settings for normal maps
                material.normalMap.wrapS = THREE.ClampToEdgeWrapping;
                material.normalMap.wrapT = THREE.ClampToEdgeWrapping;
                material.normalMap.offset.set(0, 0);
                material.normalMap.repeat.set(1, 1);
                
                // IMPORTANT: Set normal map intensity - reduced to minimize seam shimmer
                if (material.normalScale) {
                  material.normalScale.set(0.8, 0.8); // Slightly reduced to soften seam transitions
                  console.log('  üó∫Ô∏è Normal map found! Intensity set to 0.8 (reduced for seam smoothing)');
                } else {
                  material.normalScale = new THREE.Vector2(0.8, 0.8);
                  console.log('  üó∫Ô∏è Normal map found! Intensity set to 0.8 (reduced for seam smoothing)');
                }
              }
            } else {
              console.log('  ‚ö†Ô∏è NO NORMAL MAP - this will cause flat/blocky lighting');
            }
            if (material.roughnessMap) {
              material.roughnessMap.colorSpace = THREE.LinearSRGBColorSpace;
              material.roughnessMap.generateMipmaps = true;
              material.roughnessMap.minFilter = THREE.LinearMipmapLinearFilter;
              material.roughnessMap.magFilter = THREE.LinearFilter;
              material.roughnessMap.anisotropy = renderer.capabilities.getMaxAnisotropy();
              material.roughnessMap.wrapS = THREE.ClampToEdgeWrapping;
              material.roughnessMap.wrapT = THREE.ClampToEdgeWrapping;
              material.roughnessMap.offset.set(0, 0);
              material.roughnessMap.repeat.set(1, 1);
            }
            if (material.metalnessMap) {
              material.metalnessMap.colorSpace = THREE.LinearSRGBColorSpace;
              material.metalnessMap.generateMipmaps = true;
              material.metalnessMap.minFilter = THREE.LinearMipmapLinearFilter;
              material.metalnessMap.magFilter = THREE.LinearFilter;
              material.metalnessMap.anisotropy = renderer.capabilities.getMaxAnisotropy();
              material.metalnessMap.wrapS = THREE.ClampToEdgeWrapping;
              material.metalnessMap.wrapT = THREE.ClampToEdgeWrapping;
              material.metalnessMap.offset.set(0, 0);
              material.metalnessMap.repeat.set(1, 1);
            }
            
            // Enhance material properties for photogrammetry and reduce shimmer
            if (material.isMeshStandardMaterial || material.isMeshPhysicalMaterial) {
              if (ANTI_SEAM_MODE) {
                // Aggressive anti-seam settings
                material.envMapIntensity = 0.0; // Completely disable environment reflection
                material.roughness = 1.0; // Maximum roughness to eliminate reflections
                material.metalness = 0.0; // No metallic properties
                console.log('  üö´ ANTI-SEAM MODE: Eliminated all reflective properties');
              } else {
                material.envMapIntensity = 0.1; // Further reduce environment reflection to minimize shimmer
                material.roughness = Math.max(material.roughness, 0.9); // Make even less shiny to reduce reflections
                material.metalness = Math.min(material.metalness, 0.05); // Further reduce metallic look
              }
              
              // Ensure the material is set to receive lighting properly
              material.flatShading = false; // Ensure smooth shading
              
              // Additional anti-shimmer settings
              material.transparent = false; // Ensure not transparent unless needed
              material.alphaTest = 0; // Disable alpha testing unless needed
              material.side = THREE.FrontSide; // Only render front faces
              
              // Anti-normal-seam shimmer settings (only if normal maps enabled)
              if (!DISABLE_NORMAL_MAPS) {
                material.normalMapType = THREE.TangentSpaceNormalMap; // Ensure proper normal map type
                material.vertexNormals = true; // Use vertex normals for smoother transitions
              }
              
              console.log('  ‚öôÔ∏è Material enhanced for photogrammetry with anti-shimmer and anti-seam settings');
            }
            
            // Force material update
            material.needsUpdate = true;
          }
          
          // Enable shadow casting and receiving
          child.castShadow = true;
          child.receiveShadow = true;
          
          // Check geometry for normal attributes
          if (child.geometry) {
            const hasNormals = child.geometry.attributes.normal;
            const hasUVs = child.geometry.attributes.uv;
            console.log(`  üìê Geometry: normals=${!!hasNormals}, UVs=${!!hasUVs}`);
            
            if (!hasNormals) {
              console.log('  ‚ö†Ô∏è NO VERTEX NORMALS - computing normals for smooth lighting');
              child.geometry.computeVertexNormals();
            } else {
              // Smooth out vertex normals to reduce seam shimmer
              console.log('  üîß Smoothing vertex normals to reduce seam artifacts');
              child.geometry.normalizeNormals(); // Ensure normals are properly normalized
            }
            
            // Ensure geometry is optimized for smooth normal transitions
            if (hasUVs) {
              console.log('  üìç UV coordinates present - good for texture mapping');
            }
          }
        }
      });
      
      scene.add(wreck);
      
      const box = new THREE.Box3().setFromObject(wreck);
      const sz = box.getSize(new THREE.Vector3()).length();
      const ctr = box.getCenter(new THREE.Vector3());
      wreck.position.sub(ctr); // centre
      
      // Reset camera and controls
      controls.target.set(0, 0, 0);
      camera.position.set(0, sz * 0.3, sz * 0.8);
      
      // Reset VR dolly position
      dolly.position.set(0, 0, 0);
      dolly.rotation.set(0, 0, 0);
      
      // Hide loading indicator
      loadingDiv.style.display = 'none';
      
      // Log texture memory usage
      const memoryInfo = getTextureMemoryUsage(wreck);
      console.log(`${MODEL_CONFIG.name} loaded successfully`);
      console.log(`Texture memory usage: ${memoryInfo.totalMB}MB across ${memoryInfo.textureCount} textures`);
    },
    progress => {
      if (progress.lengthComputable) {
        const percentComplete = progress.loaded / progress.total * 100;
        loadingDiv.innerHTML = `Loading ${MODEL_CONFIG.name}... ${Math.round(percentComplete)}%`;
      }
    },
    err => {
      console.error(`${MODEL_CONFIG.name} loading failed:`, err);
      loadingDiv.innerHTML = `Failed to load ${MODEL_CONFIG.name}`;
      loadingDiv.style.color = '#ff6666';
      setTimeout(() => {
        loadingDiv.style.display = 'none';
        loadingDiv.style.color = 'white';
      }, 3000);
    }
  );
}

// Function to clear all measurements
function clearAllMeasurements() {
  // Clear VR measurements
  placedSpheres.forEach(sphere => scene.remove(sphere));
  placedSpheres.length = 0;
  
  // Clear desktop measurements
  desktopMeasurementPoints.forEach(sphere => scene.remove(sphere));
  desktopMeasurementPoints.length = 0;
  
  // Remove lines
  if (connectionLine) {
    scene.remove(connectionLine);
    connectionLine = null;
  }
  if (desktopMeasurementLine) {
    scene.remove(desktopMeasurementLine);
    desktopMeasurementLine = null;
  }
  
  // Hide measurement sprite
  if (measurementSprite) {
    measurementSprite.visible = false;
  }
  
  // Reset measurement modes
  desktopMeasurementMode = false;
  measurementSystemEnabled = true;
  
  // Update panel
  updateMeasurementPanel();
}

// Load the model
loadModel();

// Set initial dropdown value and add event listener
const modelSelect = document.getElementById('modelSelect');
modelSelect.value = currentModelKey;

modelSelect.addEventListener('change', (event) => {
  const selectedModel = event.target.value;
  console.log('üîÑ Switching to model:', selectedModel);
  loadModel(selectedModel);
});

// Function to create measurement display
function createMeasurementDisplay(distance) {
  // Create canvas for text
  if (!measurementCanvas) {
    measurementCanvas = document.createElement('canvas');
    measurementCanvas.width = 256;
    measurementCanvas.height = 64;
  }
  
  const context = measurementCanvas.getContext('2d');
  context.clearRect(0, 0, measurementCanvas.width, measurementCanvas.height);
  
  // Calculate proportional font size based on distance with smooth transitions
  const baseFontSize = 24;
  let scaleFactor;
  
  if (distance <= 2.0) {
    // Scale smoothly from 0-2m (0.4 to 0.7)
    scaleFactor = 0.4 + (distance / 2.0) * 0.3;
  } else if (distance <= 4.0) {
    // Scale smoothly from 2-4m (0.7 to 0.9)
    scaleFactor = 0.7 + ((distance - 2.0) / 2.0) * 0.2;
  } else {
    // Scale up from 4m to 20m (0.9 to 1.4)
    const progress = Math.min((distance - 4.0) / 16.0, 1.0); // 16m range (4m to 20m)
    scaleFactor = 0.9 + progress * 0.5; // Scale from 0.9 to 1.4
  }
  
  const fontSize = Math.round(baseFontSize * scaleFactor);
  
  // Measure text to get proper background size
  context.font = `600 ${fontSize}px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, sans-serif`;
  const text = `${distance.toFixed(2)}m`;
  const textMetrics = context.measureText(text);
  const textWidth = textMetrics.width;
  const textHeight = fontSize;
  
  // Add padding proportional to font size
  const padding = Math.max(6, fontSize * 0.3);
  const bgWidth = textWidth + (padding * 2);
  const bgHeight = textHeight + (padding * 2);
  
  // Calculate position to center the background
  const bgX = (measurementCanvas.width - bgWidth) / 2;
  const bgY = (measurementCanvas.height - bgHeight) / 2;
  
  // Draw background with rounded corners
  context.fillStyle = 'rgba(0, 0, 0, 0.8)';
  context.beginPath();
  context.roundRect(bgX, bgY, bgWidth, bgHeight, Math.max(4, fontSize * 0.2));
  context.fill();
  
  // Draw text centered
  context.fillStyle = 'white';
  context.textAlign = 'center';
  context.textBaseline = 'middle';
  context.fillText(text, measurementCanvas.width / 2, measurementCanvas.height / 2);
  
  // Create or update texture
  if (!measurementTexture) {
    measurementTexture = new THREE.CanvasTexture(measurementCanvas);
  } else {
    measurementTexture.needsUpdate = true;
  }
  
  // Create or update sprite with proportional scaling
  if (!measurementSprite) {
    const spriteMaterial = new THREE.SpriteMaterial({ map: measurementTexture });
    measurementSprite = new THREE.Sprite(spriteMaterial);
  }
  
  // Scale sprite proportionally to distance
  const baseScale = 0.3;
  const spriteScale = baseScale * scaleFactor;
  const aspectRatio = measurementCanvas.width / measurementCanvas.height;
  measurementSprite.scale.set(spriteScale * aspectRatio, spriteScale, 1);
  
  return measurementSprite;
}

// Initialize VR controllers - simplified approach with proper race condition fixes
const controllerModelFactory = new XRControllerModelFactory();
let controller1, controller2, controllerGrip1, controllerGrip2;

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 1. Build two placeholder controllers + grips immediately
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const controllers = [];
const controllerGrips = [];

for (let i = 0; i < 2; i++) {
  const ctrl = renderer.xr.getController(i);
  const grip = renderer.xr.getControllerGrip(i);
  grip.add(controllerModelFactory.createControllerModel(grip));

  // Add to scene now ‚Äì they'll be invisible until `connected`
  dolly.add(ctrl);
  dolly.add(grip);

  controllers.push(ctrl);
  controllerGrips.push(grip);
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 2. Use the controller's own events
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
controllers.forEach((ctrl, index) => {
  ctrl.addEventListener('connected', evt => {
    const { handedness, targetRayMode } = evt.data;
    if (targetRayMode !== 'tracked-pointer') return; // skip hands

    // Assign the global refs your measurement code expects
    if (handedness === 'left') {
      controller1 = ctrl;
      controllerGrip1 = controllerGrips[index];
    } else if (handedness === 'right') {
      controller2 = ctrl;
      controllerGrip2 = controllerGrips[index];
    }

    ctrl.userData.handedness = handedness;
    ctrl.userData.initialised = true;
    console.log(`‚úÖ ${handedness} controller connected`);
  });

  ctrl.addEventListener('disconnected', () => {
    const hand = ctrl.userData.handedness;
    if (hand === 'left') { controller1 = controllerGrip1 = null; }
    if (hand === 'right') { controller2 = controllerGrip2 = null; }
    console.log(`‚ùå ${hand} controller disconnected`);
  });
});

// Enhanced VR movement - always smooth
function vrMove(dt) {
  const session = renderer.xr.getSession();
  if (!session || session.visibilityState !== 'visible') {
    return;
  }

  if (!controller1 || !controller2) {
    return; // Controllers should be initialized by events, not here
  }

  // Process input sources - improved with better error checking
  for (let i = 0; i < session.inputSources.length; i++) {
    const src = session.inputSources[i];
    
    // Enhanced validation - check if controller is fully ready
    if (!src || !src.gamepad || !src.gamepad.buttons || !src.gamepad.axes || src.gamepad.axes.length < 4) {
      continue; // Graceful skipping - continue to next controller if current one isn't ready
    }

    const gamepad = src.gamepad;
    const hand = src.handedness;
    const controller = hand === 'left' ? controller1 : controller2;
    
    // Log button states for debugging
    const buttonStates = gamepad.buttons.map((btn, idx) => `${idx}:${btn?.pressed ? 'P' : 'R'}`).join(' ');
    const axesValues = gamepad.axes.map((axis, idx) => `${idx}:${axis?.toFixed(2)}`).join(' ');
    console.log(`${hand} controller - Buttons: ${buttonStates} | Axes: ${axesValues}`);
    
    // Skip if controller not available
    if (!controller) {
      console.log(`No controller object for ${hand} hand`);
      continue;
    }
    
    // Handle measurement system toggle with right controller Y button
    if (src.handedness === 'right') {
      // Y button is button[3] on Quest controllers - add safety check
      const yButton = gamepad.buttons[3];
      const yButtonCurrentlyPressed = yButton ? yButton.pressed : false;
      
      if (yButtonCurrentlyPressed !== yButtonPressed) {
        console.log(`Y button state changed: ${yButtonPressed} -> ${yButtonCurrentlyPressed}`);
      }
      
      if (yButtonCurrentlyPressed && !yButtonPressed) {
        // Button just pressed - toggle measurement system
        measurementSystemEnabled = !measurementSystemEnabled;
        console.log('Measurement system toggled:', measurementSystemEnabled);
        
        if (!measurementSystemEnabled) {
          // Disable: hide ghost spheres and clear existing measurements
          ghostSpheres.left.visible = false;
          ghostSpheres.right.visible = false;
          
          // Remove placed spheres
          placedSpheres.forEach(sphere => scene.remove(sphere));
          placedSpheres.length = 0;
          
          // Remove line and measurement display
          if (connectionLine) {
            scene.remove(connectionLine);
            connectionLine = null;
          }
          if (measurementSprite) {
            measurementSprite.visible = false;
          }
          console.log('Cleared all measurements');
        }
      }
      yButtonPressed = yButtonCurrentlyPressed;
    }
    
    // Initialize trigger state if not exists
    if (ghostSpheres[hand] && !ghostSpheres[hand].hasOwnProperty('triggerPressed')) {
      ghostSpheres[hand].triggerPressed = false;
      console.log(`Initialized trigger state for ${hand} hand`);
    }
    
    // Update ghost sphere position (only if measurement system is enabled)
    if (ghostSpheres[hand] && controller && measurementSystemEnabled) {
      try {
        controller.getWorldPosition(ghostSpheres[hand].position);
        ghostSpheres[hand].visible = true;
        console.log(`${hand} ghost sphere position:`, ghostSpheres[hand].position);
      } catch (error) {
        console.error(`Failed to get ${hand} controller position:`, error);
        continue;
      }
      
      // Check trigger (button 0) with safety check
      const triggerButton = gamepad.buttons[0];
      const triggerCurrentlyPressed = triggerButton ? triggerButton.pressed : false;
      
      if (triggerCurrentlyPressed !== ghostSpheres[hand].triggerPressed) {
        console.log(`${hand} trigger state changed:`, ghostSpheres[hand].triggerPressed, '->', triggerCurrentlyPressed);
      }
      
      if (!triggerCurrentlyPressed && ghostSpheres[hand].triggerPressed) {
        // Trigger just released - place sphere
        console.log('Placing sphere for', hand, 'hand at position:', ghostSpheres[hand].position);
        
        // If we already have max spheres, remove the oldest one
        if (placedSpheres.length >= MAX_SPHERES) {
          const oldestSphere = placedSpheres.shift();
          scene.remove(oldestSphere);
          console.log('Removed oldest sphere, now have', placedSpheres.length, 'spheres');
          
          // Remove existing line when removing spheres
          if (connectionLine) {
            scene.remove(connectionLine);
            connectionLine = null;
            console.log('Removed connection line');
          }
        }
        
        // Place new sphere at controller position
        const newSphere = new THREE.Mesh(sphereGeometry, placedMaterial);
        newSphere.position.copy(ghostSpheres[hand].position);
        scene.add(newSphere);
        placedSpheres.push(newSphere);
        console.log('Added new sphere, now have', placedSpheres.length, 'spheres');
        
        // Create line if we have exactly 2 spheres
        if (placedSpheres.length === 2) {
          const distance = placedSpheres[0].position.distanceTo(placedSpheres[1].position);
          console.log('Creating measurement line, distance:', distance.toFixed(2), 'm');
          
          const lineGeometry = new LineGeometry();
          const positions = [];
          positions.push(
            placedSpheres[0].position.x, placedSpheres[0].position.y, placedSpheres[0].position.z,
            placedSpheres[1].position.x, placedSpheres[1].position.y, placedSpheres[1].position.z
          );
          lineGeometry.setPositions(positions);
          
          if (connectionLine) {
            scene.remove(connectionLine);
          }
          connectionLine = new Line2(lineGeometry, vrLineMaterial);
          connectionLine.computeLineDistances();
          scene.add(connectionLine);
          
          // Calculate distance and create measurement display
          createMeasurementDisplay(distance);
          
          // Add measurement sprite to scene if not already added
          if (measurementSprite && !scene.children.includes(measurementSprite)) {
            scene.add(measurementSprite);
            console.log('Added measurement sprite to scene');
          }
        }
        
        // Update panel after placing sphere
        updateMeasurementPanel();
      }
      
      // Update trigger state
      ghostSpheres[hand].triggerPressed = triggerCurrentlyPressed;
    } else if (!measurementSystemEnabled && ghostSpheres[hand]) {
      // Hide ghost spheres when measurement system is disabled
      ghostSpheres[hand].visible = false;
    }

    // Movement controls - axes already validated above
    const x = gamepad.axes[2] || 0; // strafe/turn
    const y = gamepad.axes[3] || 0; // walk/fly (-y = forward)

    // Log movement if significant
    if (Math.abs(x) > 0.1 || Math.abs(y) > 0.1) {
      console.log(`${hand} movement: x=${x.toFixed(2)}, y=${y.toFixed(2)}`);
    }

    if (src.handedness === 'left') {
      // Cancel focus animation if user starts moving
      if (focusAnimation && (Math.abs(x) > 0.1 || Math.abs(y) > 0.1)) {
        cancelAnimationFrame(focusAnimation);
        focusAnimation = null;
        console.log('Cancelled focus animation due to left controller movement');
      }
      
      // Speed boost with grip/squeeze (button 1) - add safety check
      const gripButton = gamepad.buttons[1];
      const speedMultiplier = (gripButton && gripButton.pressed) ? 3 : 1;
      const speed = MOVE_SPEED * speedMultiplier * dt;
      
      if (speedMultiplier > 1) {
        console.log('Left grip pressed - speed boost active');
      }
      
      const forward = new THREE.Vector3();
      camera.getWorldDirection(forward);
      forward.y = 0; // Lock to dolly's yaw
      forward.normalize();
      
      const right = new THREE.Vector3().crossVectors(forward, camera.up).normalize();
      
      // Horizontal movement ONLY (forward/back, strafe)
      if (Math.abs(y) > 0.1) {
        dolly.position.addScaledVector(forward, -y * speed); // Negative for forward
        console.log('Left controller forward/back movement:', (-y * speed).toFixed(3));
      }
      if (Math.abs(x) > 0.1) {
        dolly.position.addScaledVector(right, x * speed);
        console.log('Left controller strafe movement:', (x * speed).toFixed(3));
      }
    }
    
    if (src.handedness === 'right') {
      // Cancel focus animation if user starts turning/flying
      if (focusAnimation && (Math.abs(x) > 0.1 || Math.abs(y) > 0.1)) {
        cancelAnimationFrame(focusAnimation);
        focusAnimation = null;
        console.log('Cancelled focus animation due to right controller movement');
      }
      
      // Speed boost with grip/squeeze (button 1) - only for vertical movement
      const gripButton = gamepad.buttons[1];
      const verticalSpeedMultiplier = (gripButton && gripButton.pressed) ? 3 : 1;
      
      if (verticalSpeedMultiplier > 1) {
        console.log('Right grip pressed - vertical speed boost active');
      }
      
      // Smooth turning with right stick X (no speed boost)
      if (Math.abs(x) > 0.1) {
        dolly.rotation.y -= x * TURN_SPEED * dt; // No speed multiplier for turning
        console.log('Right controller turn:', (x * TURN_SPEED * dt).toFixed(3));
      }
      
      // Vertical movement with right stick Y (with speed boost)
      if (Math.abs(y) > 0.1) {
        dolly.position.y -= y * FLY_SPEED * verticalSpeedMultiplier * dt;
        console.log('Right controller vertical movement:', (-y * FLY_SPEED * verticalSpeedMultiplier * dt).toFixed(3));
      }
    }
  }
}

// Create desktop measurement display element
function createDesktopMeasurementDisplay() {
  if (desktopMeasurementDisplay) return;
  
  desktopMeasurementDisplay = document.createElement('div');
  desktopMeasurementDisplay.style.cssText = `
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 12px 16px;
    border-radius: 8px;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    font-size: 18px;
    font-weight: 600;
    z-index: 100;
    display: none;
    border: 2px solid rgba(255, 255, 255, 0.3);
  `;
  document.body.appendChild(desktopMeasurementDisplay);
}

// Initialize desktop measurement display
createDesktopMeasurementDisplay();

// Desktop measurement spheres - make twice as big and white
const desktopSphereGeometry = new THREE.SphereGeometry(0.04, 12, 8); // 8cm radius, twice as big
const desktopSphereMaterial = new THREE.MeshBasicMaterial({color: 0xffffff}); // White instead of red

// Update desktop measurement to use the panel
function updateDesktopMeasurement() {
  updateMeasurementPanel();
  
  if (desktopMeasurementPoints.length === 2) {
    // Create or update line with enhanced visibility
    if (desktopMeasurementLine) {
      scene.remove(desktopMeasurementLine);
    }
    
    const lineGeometry = new LineGeometry();
    const positions = [];
    positions.push(
      desktopMeasurementPoints[0].position.x, desktopMeasurementPoints[0].position.y, desktopMeasurementPoints[0].position.z,
      desktopMeasurementPoints[1].position.x, desktopMeasurementPoints[1].position.y, desktopMeasurementPoints[1].position.z
    );
    lineGeometry.setPositions(positions);
    
    desktopMeasurementLine = new Line2(lineGeometry, desktopLineMaterial);
    desktopMeasurementLine.computeLineDistances();
    scene.add(desktopMeasurementLine);
  } else {
    if (desktopMeasurementLine) {
      scene.remove(desktopMeasurementLine);
      desktopMeasurementLine = null;
    }
  }
}

// Update clear function to refresh panel
function clearDesktopMeasurement() {
  desktopMeasurementPoints.forEach(sphere => scene.remove(sphere));
  desktopMeasurementPoints.length = 0;
  
  if (desktopMeasurementLine) {
    scene.remove(desktopMeasurementLine);
    desktopMeasurementLine = null;
  }
  
  updateMeasurementPanel();
}

// Add this variable declaration near the top with other variables (around line 100)
let lastTime = 0;

// Add VR session event listeners to handle mode transitions
renderer.xr.addEventListener('sessionstart', () => {
  console.log('VR session started');
  updateMeasurementPanel();
  syncMeasurementToVR();
});

renderer.xr.addEventListener('sessionend', () => {
  console.log('VR session ended');
  
  // Get the current camera position from the dolly before resetting
  const vrCameraPosition = new THREE.Vector3();
  camera.getWorldPosition(vrCameraPosition);
  
  // Reset the dolly position and rotation
  dolly.position.set(0, 0, 0);
  dolly.rotation.set(0, 0, 0);
  
  // Set the camera position directly (outside the dolly)
  camera.position.copy(vrCameraPosition);
  
  // If we have measurements, set orbit target to measurement center
  if (placedSpheres.length === 2) {
    const measurementCenter = new THREE.Vector3();
    measurementCenter.addVectors(placedSpheres[0].position, placedSpheres[1].position);
    measurementCenter.multiplyScalar(0.5);
    controls.target.copy(measurementCenter);
    console.log('Set orbit controls target to measurement center:', measurementCenter);
  } else {
    // No measurements, keep the default target
    controls.target.set(0, 0, 0);
  }
  
  // Reset and enable orbit controls
  controls.enabled = true;
  controls.update();
  
  updateMeasurementPanel();
  syncMeasurementToDesktop();
  
  // Hide ghost spheres when swapping back to desktop
  ghostSpheres.left.visible = false;
  ghostSpheres.right.visible = false;
});

// Function to sync desktop measurements to VR format
function syncMeasurementToVR() {
  if (desktopMeasurementPoints.length === 2) {
    // Clear existing VR measurements
    placedSpheres.forEach(sphere => scene.remove(sphere));
    placedSpheres.length = 0;
    
    // Convert desktop measurements to VR format
    desktopMeasurementPoints.forEach(point => {
      const newSphere = new THREE.Mesh(sphereGeometry, placedMaterial);
      newSphere.position.copy(point.position);
      scene.add(newSphere);
      placedSpheres.push(newSphere);
    });
    
    // Create VR line if we have 2 points
    if (placedSpheres.length === 2) {
      const distance = placedSpheres[0].position.distanceTo(placedSpheres[1].position);
      
      const lineGeometry = new LineGeometry();
      const positions = [];
      positions.push(
        placedSpheres[0].position.x, placedSpheres[0].position.y, placedSpheres[0].position.z,
        placedSpheres[1].position.x, placedSpheres[1].position.y, placedSpheres[1].position.z
      );
      lineGeometry.setPositions(positions);
      
      if (connectionLine) {
        scene.remove(connectionLine);
      }
      connectionLine = new Line2(lineGeometry, vrLineMaterial);
      connectionLine.computeLineDistances();
      scene.add(connectionLine);
      
      // Create measurement display
      createMeasurementDisplay(distance);
      if (measurementSprite && !scene.children.includes(measurementSprite)) {
        scene.add(measurementSprite);
      }
    }
    
    console.log('Synced desktop measurements to VR format');
  }
}

// Function to sync VR measurements to desktop format
function syncMeasurementToDesktop() {
  if (placedSpheres.length === 2) {
    // Clear existing desktop measurements
    desktopMeasurementPoints.forEach(sphere => scene.remove(sphere));
    desktopMeasurementPoints.length = 0;
    
    // Convert VR measurements to desktop format
    placedSpheres.forEach(sphere => {
      const newSphere = new THREE.Mesh(sphereGeometry, placedMaterial);
      newSphere.position.copy(sphere.position);
      scene.add(newSphere);
      desktopMeasurementPoints.push(newSphere);
    });
    
    // Create desktop line if we have 2 points
    if (desktopMeasurementPoints.length === 2) {
      const lineGeometry = new LineGeometry();
      const positions = [];
      positions.push(
        desktopMeasurementPoints[0].position.x, desktopMeasurementPoints[0].position.y, desktopMeasurementPoints[0].position.z,
        desktopMeasurementPoints[1].position.x, desktopMeasurementPoints[1].position.y, desktopMeasurementPoints[1].position.z
      );
      lineGeometry.setPositions(positions);
      
      if (desktopMeasurementLine) {
        scene.remove(desktopMeasurementLine);
      }
      desktopMeasurementLine = new Line2(lineGeometry, desktopLineMaterial);
      desktopMeasurementLine.computeLineDistances();
      scene.add(desktopMeasurementLine);
      
      // Enable desktop measurement mode if we have measurements
      desktopMeasurementMode = true;
    }
    
    // Hide VR measurement sprite
    if (measurementSprite) {
      measurementSprite.visible = false;
    }
    
    console.log('Synced VR measurements to desktop format');
    
    // Force panel update after sync
    updateMeasurementPanel();
  } else if (placedSpheres.length === 0) {
    // If no VR measurements, ensure desktop mode is properly reset
    desktopMeasurementMode = false;
    updateMeasurementPanel();
  }
}

// Optimize renderer settings for reduced shimmer and faster loading/rendering
renderer.shadowMap.enabled = false; // Disable shadows if not needed
renderer.physicallyCorrectLights = false;
renderer.toneMapping = THREE.ACESFilmicToneMapping; // Keep consistent tone mapping
renderer.toneMappingExposure = 1.0; // Consistent with main renderer settings

// Additional anti-shimmer settings
renderer.sortObjects = true; // Ensure proper depth sorting
renderer.logarithmicDepthBuffer = false; // Standard depth buffer for better performance

// Reduce pixel ratio on mobile for better performance and less shimmer
if (window.devicePixelRatio > 2) {
  renderer.setPixelRatio(2.0); // Increased from 1.5 but still capped
}

// Update the render loop to handle desktop measurement line pulsing and sprite positioning
renderer.setAnimationLoop(time => {
  const t = time;
  const dt = Math.min((time - lastTime) / 1000, 0.1);
  lastTime = time;

  // IMPORTANT: Set resolution BEFORE rendering
  const width = renderer.domElement.width;
  const height = renderer.domElement.height;
  vrLineMaterial.resolution.set(width, height);
  desktopLineMaterial.resolution.set(width, height);

  // Update desktop measurement line pulsing effect - 50% to 90% opacity
  if (desktopMeasurementLine && !renderer.xr.isPresenting) {
    const pulse = (Math.sin(t * 0.004) + 1) * 0.2 + 0.5;
    desktopLineMaterial.opacity = pulse;
    desktopMeasurementLine.visible = true; // Force visible
  } else if (desktopMeasurementLine) {
    desktopMeasurementLine.visible = false; // Hide in VR
  }
  
  // Update VR measurement display - 50% to 90% opacity
  if (connectionLine && measurementSystemEnabled && renderer.xr.isPresenting) {
    const pulse = (Math.sin(t * 0.003) + 1) * 0.2 + 0.5;
    vrLineMaterial.opacity = pulse;
    connectionLine.visible = true; // Force visible
    
    // Position measurement sprite at the center of the line
    if (measurementSprite && placedSpheres.length === 2) {
      try {
        // Calculate midpoint between the two spheres
        const midpoint = new THREE.Vector3();
        midpoint.addVectors(placedSpheres[0].position, placedSpheres[1].position);
        midpoint.multiplyScalar(0.5);
        
        // Get current distance for proportional offset
        const currentDistance = placedSpheres[0].position.distanceTo(placedSpheres[1].position);
        const offsetScale = Math.max(0.1, Math.min(0.3, currentDistance * 0.05)); // Scale offset with distance
        
        // Position sprite at midpoint with proportional offset upward
        measurementSprite.position.copy(midpoint);
        measurementSprite.position.y += offsetScale;
        
        // Disable depth testing so text is always visible
        measurementSprite.material.depthTest = false;
        measurementSprite.material.depthWrite = false;
        measurementSprite.material.opacity = 0.9;
        measurementSprite.material.transparent = true;
        measurementSprite.visible = true;
      } catch (error) {
        console.error('Error positioning measurement sprite:', error);
      }
    }
  } else if (connectionLine) {
    connectionLine.visible = false; // Hide in desktop
  }
  
  if (renderer.xr.isPresenting) {
    vrMove(dt);
    controls.enabled = false;
  } else {
    controls.enabled = true;
    controls.update();
  }
  
  renderer.render(scene, camera);
});

// Initialize panel state
updateMeasurementPanel();

// Register service worker for PWA functionality
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./sw.js')
      .then(registration => {
        console.log('‚úÖ Service Worker registered successfully:', registration.scope);
      })
      .catch(error => {
        console.log('‚ùå Service Worker registration failed:', error);
      });
  });
}

// Function to monitor texture memory usage
function getTextureMemoryUsage(object) {
  let totalMemory = 0;
  const textures = new Set();
  
  object.traverse((child) => {
    if (child.isMesh && child.material) {
      const material = child.material;
      
      // Check all possible texture maps
      const textureProps = ['map', 'normalMap', 'roughnessMap', 'metalnessMap', 'aoMap', 'emissiveMap'];
      textureProps.forEach(prop => {
        if (material[prop] && !textures.has(material[prop])) {
          textures.add(material[prop]);
          const texture = material[prop];
          if (texture.image) {
            const width = texture.image.width || 1024;
            const height = texture.image.height || 1024;
            const bytesPerPixel = 4; // RGBA
            const memory = width * height * bytesPerPixel;
            totalMemory += memory;
          }
        }
      });
    }
  });
  
  return {
    totalMB: Math.round(totalMemory / (1024 * 1024)),
    textureCount: textures.size
  };
}

// Function to enhance materials with generated normal maps if missing
function enhanceWithGeneratedNormals(material) {
  if (!material.normalMap && material.map) {
    // We could generate a normal map from the diffuse texture
    // This is a basic approach - real normal maps from Metashape would be much better
    console.log('Consider re-exporting from Metashape with normal maps enabled');
    
    // Increase normal scale if normal map exists but looks weak
    if (material.normalMap && material.normalScale) {
      material.normalScale.set(2.0, 2.0); // Increase normal map intensity
    }
  }
}
</script>
</body>
</html>
